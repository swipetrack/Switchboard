## The Injector Locator Pattern

When object instantiation is out of your control, and constructor injection is impossible, it may be necessary to use a static reference to satisfy certain dependencies. That is why Unity dependency injection frameworks, if they even support injecting editor insantiated objects, use a service locator of some kind to do it. However, the service locator should not be fully implemented. If abstract, the service locator can function much like an interface. For that purpose, the InjectorLocator was created. It serves as a static reference point with a single responsibility, to provide an IInjector interface. The IInjector has a generic method that can then provide an instance of any type.

One concern with static references is that they are globally accessible. Global values can be altered from anywhere, potentially corrupting the state of the application. The IInjector assigned to the InjectorLocator could be removed while the application is running. However, C# delegates provide a way of setting a global value, and keeping access private for the setter. Delegates can refer to private or protected methods, enabling classes to hide public access to a method delegate. If a global value is actually a delegate that returns the desired value, a private method delegate can be assigned. Global access to remove the assigned delegate can then be restricted, unless the matching delegate is provided. Therefore, even though the static value is global, if the assigned delegate is private, it cannot be removed by an external agent.

## The IInjector Interface

The IInjector interface is the fundamental interface for dependency injection. It consists of a single, generic method. The generic type argument specifies the type of object requested from the IInjector. The IInjector can return an instance of that type, but it may return null if it cannot fulfill the request. Once you have an IInjector instance, you can request any type of object from it, and it is all done via loose coupling.
