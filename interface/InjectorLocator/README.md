
# Injector Locator

When object instantiation, calling constructors, and dependency injection are out of your control due to the programming environment it becomes necessary to call upon a static reference in order to satisfy dependencies. However, this need not be an overly explicit or concrete implementation of any particular service provider. Following abstraction to its ultimate conclusion, the static reference itself can be abstracted almost away entirely. To this end, I created a static class called InjectorLocator. This class functions as a static point of reference that bridges the gap between two sides of the development environment. On one side you have the composition root of your application, the main entry point, containing various objects that your application depends upon. On the other side are the objects that are being instantiated by the environment.

There are two public members for interacting with the Injector Locator, one for each side of the environment. When the application launches from the composition root, objects that can provide dependencies register with the Injector Locator as observers of an event to be invoked when a new objects request dependency injection. When new objects are created, they reference the InjectorLocator to call a method which requests dependency injection. Calling this method invokes the event. These two members of the Injector Locator operate only on abstract interfaces. The generic IInjector and IInjectable interfaces make up a pair that allow one to inject the other with an instance of a class based on the requested type. These two interfaces have no dependency on the InjectorLocator. They are fully self sufficient as an abstract dependency injection interface. Injector locator operates on these two interfaces, with IInjector implementations on the composition root side, and IInjectable objects on the other. An IInjector that observes the event receives the IInjectable that is requesting injection, and can then invoke method injection on that injectable object simply by passing itself in as an argument of the IInjectable.Inject(IInjector) method. Thus, end-to-end abstract dependency injection is achieved by allowing one, single strong dependency, dependency upon the Injector Locator pattern.

One concern of note with static references is that they are global. The properties of a global reference can be altered from anywhere, potentially corrupting the expected state. However, the C# event paradigm automatically mitigates those concerns. The ability to add and remove an observer is limited by the ability to access the method delegate that is added to the event. Delegates can refer to private or protected methods, enabling observers of the event to hide access to the method that is delegated to observe the event. Therefore, even though the event is global, if the methods added to the event are not global, they cannot be removed from the event by an external actor. Also, the event cannot be cleared of delegates because only the class that owns the event can do that. The expected state set by one observer, that it is observing the event, cannot be altered or corrupted externally. Only one with access to add the method delegate to the global event has access to remove it. Outside of C# the pattern can be replicated by recreating the functionality of the C# event paradigm. After all, it is just a hidden MultiCastDelegate with public methods to add and remove, in the form of the += and -= operators. C# just makes it easy to encapsulate the whole concept into one line of code.

The entirety of this pattern is demonstrated via Switchboard's public interface which is free and open source under the MIT license here. The entire Switchboard framework itself is designed to be loosely coupled to your application. Therefore, the only real dependency requirement is on the free, open-source implementation of this pattern. You can fully utilize the concrete implementation of IInjector that Switchboard provides, and still only depend directly on interfaces throughout your code base. Even though InjectorLocator is a static class, and technically constitues a tightly coupled dependency, it is so light weight and abstract that it effectively functions as an interface. This is the essence of the Injector Locator pattern, true loose coupling, without reflection, across a boundary that prevents constructor injection.

# IInjector & IInjectable

The IInjector interface is the fundamental interface for dependency injection. It has no dependencies and consists of a single, generic method. The generic type is automatically inferred at compile time based on the out parameter that the IInjector should provide. That type is the essential metadata that defines the request. The IInjector returns a boolean to indicate whether the dependency was provided successfully. This enables the client that is requesting the type to put the request in a conditional if statement, performing actions based on whether the IInjector indicated success. An IInjector instance can represent the entire dependency container of your application, and it can be passed as a single argument via constructor or method injection. The IInjectable interface defines support for method injection with an IInjector. This only becomes necessary when constructor injection is out of the question, as is the case when using the Injector Locator.
