<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>What is Dependency Injection? | Switchboard 1.0.0 </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="What is Dependency Injection? | Switchboard 1.0.0 ">
      
      <link rel="icon" href="../assets/SwitchboardIconBorderless16.ico">
      <link rel="stylesheet" href="../styles/docfx.min.css">
      <link rel="stylesheet" href="../styles/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      

      <script>
        MathJax = {
          options: {
            processHtmlClass: ['tex2jax_process', 'math']
          }
        };
      </script>

      <script type="text/javascript" src="../styles/docfx.min.js"></script>
      <script type="text/javascript" src="../styles/main.js"></script>
  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../assets/SwitchboardIconBorderless64.png" alt="Switchboard 1.0.0">
            Switchboard 1.0.0
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="DependencyInjection">
<h2 id="what-is-dependency-injection">What is Dependency Injection?</h2>

<p>Dependency injection occurs when one object has a dependency that some external object provides. When you instantiate a new object by calling the class contructor, and provide an argument required for instantiation, you have just performed dependency injection. In fact, this is the ideal, and most common form of dependency injection. Constructor injection should be used wherever possible. Objects that instantiate other objects should provide the dependencies of those child objects down through the hierarchy of your application. So, the dependent object does not seek out its own dependency, like with a static reference. When an object contains a direct reference to a type that it depends on, those types become tightly coupled. You cannot separate the implementation of the dependent object from the object upon which it depends. This can lead to an unecessary amount of strong dependencies throughout your code base over time, resulting in spaghetti code, where all of your classes are tangled together. They can't be separated from one another without causing compilation errors. When many classes have these types of strong dependencies it can feel like every file in the project has some chain of dependencies that ultimately reach every other file in the project. This makes it very difficult to separate your modules along clean conceptual boundaries.</p>
<p>So, what is the alternative? When we have well defined conceptual boundaries between the responsibilities of various classes and modules, those modules can be loosely coupled together via abstract interfaces. An interface provides a minimal definition for object interaction, like the required methods, properties, and events, without requiring implementation. This allows your types to depend on a simple interface, rather than an explicit implementation of a particular class. When an object depends on an interface it becomes trivial to swap the actual implementation of that interface. Also, the code is now more portable, as it only requires that interface, rather than all of the actual code behind specific dependencies.</p>
<p>Programming objects to depend on interfaces encourages <a href="https://en.wikipedia.org/wiki/SOLID">S.O.L.I.D.</a> programming and clean code architecture. Or, perhaps it is more accurate to say that S.O.L.I.D. programming is not possible without some dependencies represented as interfaces. When a type depends on an interface, the concrete implementation of that interface must be injected in from the outside. That is inversion of control. So, dependency injection is a fundamental and necessary component of truly object-oriented, modular code.</p>
<h2 id="singletons">Singletons</h2>
<p>Many Unity programmers will be familiar with using singletons, static classes, or static references to some instance. These types of dependencies are sometimes referred to as services. Other objects that depend on these services can easily access them directly via static reference. However, that creates tight coupling between the dependent object and that concrete type.</p>
<p>So, why would anyone ever use static, global references if they always result in tight coupling? Many programmers advise against it altogether. However, there are circumstances where it is unavoidable, or even preferable. When you have no choice, it becomes unhelpful to only hear that you should avoid the unavoidable. One circumstance where reaching out for a global, static reference is all but required is when you have no control over the instantiation of important objects. This is, in fact, the case in an environment such as Unity. In Unity, most scripts inherit from MonoBehaviour and are instantiated automatically via the Unity engine. By the time your MonoBehaviour script executes, it is far beyond the stage of calling a constructor. Having been constructed without an opportunity for dependency injection, few options remain for satisfying external dependencies. Usually, the script makes some kind of direct static reference to the type of dependency it needs. This is why so many Unity programmers are familiar with singletons, and all of the issues that come with them.</p>
<h2 id="unity-limitations">Unity Limitations</h2>
<p>Unity does not allow you to control instantiation of scripts derived from MonoBehaviour or ScriptableObject. The constructors are called by the Unity environment within which your scripts are interpreted. Also, there is no root entry point from which to compose the start of your application. The actual composition root of the player or editor application is again controlled by Unity, and no analogous main method is provided directly for you. There is no event invoked when a new object is created for services to observe and inject dependencies. Therefore, the scripts on these instantiated objects must directly reference some static dependency from their MonoBehaviour side of the environment. Bridging this gap between application services, scenes, and the MonoBehaviour components loaded within them, is the crucial issue that makes programming in Unity fundamentally different from many other programming environments. The consensus wisdom around dependency injection and singletons is not always directly applicable due to these environmental differences.</p>
<p>The Service Locator pattern is relevant to singletons, dependency injection, and Unity. A service locator is a singleton that provides dependencies to other objects upon request. So, it is like a singleton service that provides references to other services. This pattern inherently comes with all of the pitfalls of a singleton or static reference, like tight coupling to the service locator itself. In most other programming environments that do not restrict access to constructor based dependency injection, this pattern is treated as an anti-pattern to be avoided. However, when constructor injection is not available, a Service Locator may be unavoidable, and when the implementation is sufficiently abstract, a Service Locator can effectively represent an abstract interface. This is the inspiration for the Injector Locator pattern.</p>
<h2 id="the-injector-locator-pattern">The Injector Locator Pattern</h2>
<p>When object instantiation, calling constructors, and dependency injection are out of your control due to the programming environment it becomes necessary to call upon a static reference in order to satisfy dependencies. However, this need not be an overly explicit or concrete implementation of any particular service provider. Following abstraction to its ultimate conclusion, the static reference itself can be abstracted almost away entirely. To this end, I created a static class called <a class="xref" href="../api/Switchboard.InjectorLocator.html">InjectorLocator</a>. This class functions as a static point of reference that bridges the gap between two sides of the development environment. On one side you have the composition root of your application, the main entry point, containing various objects that your application depends upon. On the other side are the objects that are being instantiated by the environment.</p>
<p>There are two public members for interacting with the Injector Locator, one for each side of the environment. When the application launches from the composition root, objects that can provide dependencies register with the Injector Locator as observers of an event to be invoked when a new objects request dependency injection. When new objects are created, they reference the InjectorLocator to call a method which requests dependency injection. Calling this method invokes the event. These two members of the Injector Locator operate only on abstract interfaces. The generic <a class="xref" href="../api/Switchboard.IInjector.html">IInjector</a> and <a class="xref" href="../api/Switchboard.IInjectable.html">IInjectable</a> interfaces make up a pair that allow one to inject the other with an instance of a class based on the requested type. These two interfaces have no dependency on the InjectorLocator. They are fully self sufficient as an abstract dependency injection interface. Injector locator operates on these two interfaces, with IInjector implementations on the composition root side, and IInjectable objects on the other. An IInjector that observes the event receives the IInjectable that is requesting injection, and can then invoke method injection on that injectable object simply by passing itself in as an argument of the IInjectable.Inject(IInjector) method. Thus, end-to-end abstract dependency injection is achieved by allowing one, single strong dependency, dependency upon the Injector Locator pattern.</p>
<p>One concern of note with static references is that they are global. The properties of a global reference can be altered from anywhere, potentially corrupting the expected state. However, the C# event paradigm automatically mitigates those concerns. The ability to add and remove an observer is limited by the ability to access the method delegate that is added to the event. Delegates can refer to private or protected methods, enabling observers of the event to hide access to the method that is delegated to observe the event. Therefore, even though the event is global, if the methods added to the event are not global, they cannot be removed from the event by an external actor. Also, the event cannot be cleared of delegates because only the class that owns the event can do that. The expected state set by one observer, that it is observing the event, cannot be altered or corrupted externally. Only one with access to add the method delegate to the global event has access to remove it. Outside of C# the pattern can be replicated by recreating the functionality of the C# event paradigm. After all, it is just a hidden MultiCastDelegate with public methods to add and remove, in the form of the += and -= operators. C# just makes it easy to encapsulate the whole concept into one line of code.</p>
<p>The entirety of this pattern is demonstrated via Switchboard's public interface which is free and open source under the MIT license at <a href="https://github.com/swipetrack/switchboard/tree/main/interface">https://github.com/swipetrack/switchboard/tree/main/interface</a>. The entire Switchboard framework itself is designed to be loosely coupled to your application. Therefore, the only real dependency requirement is on the free, open-source implementation of this pattern. You can fully utilize the concrete implementation of IInjector that Switchboard provides, and still only depend directly on interfaces throughout your code base. Even though InjectorLocator is a static class, and technically constitues a tightly coupled dependency, it is so light weight and abstract that it effectively functions as an interface. This is the essence of the Injector Locator pattern, true loose coupling, without reflection, across a boundary that prevents constructor injection.</p>
<h2 id="iinjector-and-iinjectable">IInjector and IInjectable</h2>
<p>The IInjector interface is the fundamental interface for dependency injection. It has no dependencies and consists of a single, generic method. The generic type is automatically inferred at compile time based on the out parameter that the IInjector should provide. That type is the essential metadata that defines the request. The IInjector returns a boolean to indicate whether the dependency was provided successfully. This enables the client that is requesting the type to put the request in a conditional if statement, performing actions based on whether the IInjector indicated success. An IInjector instance can represent the entire dependency container of your application, and it can be passed as a single argument via constructor or method injection. The IInjectable interface defines support for method injection with an IInjector. This only becomes necessary when constructor injection is out of the question, as is the case when using the Injector Locator.</p>
<h2 id="other-dependency-injection-frameworks">Other Dependency Injection Frameworks</h2>
<p>You may be wondering how Switchboard compares to other dependency injection frameworks. Hopefully, if you've read this far some of the major differences may be apparent, but I will point out some of the issues that I often see in other frameworks. Many, if not all, of the other dependency injection frameworks rely heavily on reflection. Reflection refers to the ability of C# to programatically examine and invoke even private and protected members of a type or instance. Most dependency injection frameworks will have you decorate the various members of your classes with certain attributes, particular to that framework. At run time, objects undergo reflection, examining all of their members for those attributes, and injecting dependencies accordingly. The problem with reflection is that it is notoriously slow. Switchboard is designed to be used in video games with high performance requirements, therefore it does not use reflection. Also, relying on reflection can cause code stripping to automatically remove required code from your builds because it is not able to detect the reflection based dependency relationships.</p>
<p>Some frameworks have the ability to bake reflection. This is a process by which reflection occurs only at compile time, and dependency implementations are serialized for deployment, so they are pre-defined at run time. This eliminates the run time performance penalty. However, it does not eliminate the penalty all together, and it prevents dynamic alteration of baked dependencies at run time. You still have to bake, which takes time, and those baked references are locked in.</p>
<p>Switchboard has none of those issues. No reflection occurs at design time, compile time, or run time. It is avoided entirely, and the performance is nearly instantaneous. Switchboard is fully compatible with disabling domain and scene reload in Unity's enter play mode options. So, you can press play and begin working almost instantly. You can swap all of those dependency implementations in an instant. The updates are live, and they persist when you stop playing. You can drop a prefab into a scene, and it will automatically have all of it's dependencies resolved with no performance penalty. You will not find another plugin that works this way.</p>
<p>Just because you've eliminated an explicit reference to another class, does not mean that you have eliminated tight coupling. If your code base is littered with framework specific attributes, that is a tightly coupled dependency! Now, every class depends on that particular dependency injection framework. So, even though you may not be referencing the concrete type of dependency being injected, you are referencing the unique types of the particular dependency injection framework. Without that specific framework, none of your code works. When using Switchboard, you only depend on the Injector Locator pattern, which any framework can implement, and you only reference it on one line per class. Swapping out the entire plugin would be trivial.</p>
<p>I find that some plugins are too feature rich. A plethora of features may seem enticing. More is better right? Well, when the features get too idiosyncratic, they effectively constitute tight coupling to a pattern. You're boxed into doing things the way that plugin wants you to. You want that fancy feature? Well, it only works that fancy way, in that fancy plugin. If you change your mind about the plugin, the fancy feature follows. Switchboard aims to be simple and elegant. I want this plugin to get out of your way so that you can be enabled to develop faster, cleaner, more stable code without interference from a plugin.</p>
<p>Some solutions also struggle with execution order. Getting your services to load first, and persist beyond the end of all calls to OnDestroy(), is a genuine problem. Many plugins have elaborate requirements for you, the user, to deal with in order to mitigate those concerns. Switchboard has all of the execution order issues resolved for you. The composition root runs when you press play, or when the application is launched, when the first scene loaded, but before any Awake(), OnEnable(), or Start() calls occur. You can instantiate a GameObject and add components if you like, although you may no longer need to. If your code deson't need to live in a scene, it can live at the composition root. Then, when finished, the dependency container you define deactivates after all other OnDestroy() calls.</p>
<h2 id="composition-root-and-dependency-injector">Composition Root and Dependency Injector</h2>
<p>The composition root is the entry point for the application to start up at run time. This occurs when you press play in the editor, or launch the application. In the Switchboard section of the project settings menu there is a single object reference. That is where you may assign any implementation of DependencyInjector you like. The composition root is what activates and deactivates that DependencyInjector at run time. The DependencyInjector reference is cached when play begins, so changing the value after run time has no effect. DependencyInjector is a ScriptableObject, so it exists as an asset in your project rather than in the scene hierarchy. You can define multiple implementations of DependencyInjector, and you can have multiple instances of a certain type of DependencyInjector saved as assets with differing properties. The injector can be swapped out easily to change the context of your application. You can easily create a mock dependency injector and swap to it for unit testing. Any properties that you change on the dependency injector asset are live at run time, and persist after you stop playing, making testing, tweaking, and experimentation simple and intuitive.</p>
</article>

        <div class="contribution d-print-none">
        </div>

        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span> <span>Switchboard was created by <a href="https://www.linkedin.com/in/ronnie-moon-12209380/">Ronnie Moon</a>.  Copyright © 2023 <a href="http://www.swipetrack.com/">SwipeTrack Solutions</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>